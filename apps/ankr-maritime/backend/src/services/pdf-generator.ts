import PDFDocument from 'pdfkit';

interface PdfRow {
  label: string;
  value: string;
  bold?: boolean;
  color?: string;
}

interface PdfTableRow {
  cells: string[];
  bold?: boolean;
}

export function generatePdf(options: {
  title: string;
  subtitle?: string;
  sections: {
    heading?: string;
    rows?: PdfRow[];
    table?: { headers: string[]; rows: PdfTableRow[]; columnWidths?: number[] };
    spacer?: boolean;
  }[];
}): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ margin: 50, size: 'A4' });
    const chunks: Buffer[] = [];

    doc.on('data', (chunk: Buffer) => chunks.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    doc.on('error', reject);

    // Header
    doc.fontSize(18).font('Helvetica-Bold').text(options.title, { align: 'center' });
    if (options.subtitle) {
      doc.fontSize(10).font('Helvetica').fillColor('#666666').text(options.subtitle, { align: 'center' });
    }
    doc.moveDown(0.5);
    doc.strokeColor('#1e3a5f').lineWidth(1).moveTo(50, doc.y).lineTo(545, doc.y).stroke();
    doc.moveDown();

    for (const section of options.sections) {
      if (section.spacer) {
        doc.moveDown();
        continue;
      }

      if (section.heading) {
        doc.fontSize(12).font('Helvetica-Bold').fillColor('#0a2744').text(section.heading);
        doc.moveDown(0.3);
      }

      if (section.rows) {
        for (const row of section.rows) {
          const y = doc.y;
          doc.fontSize(9).font(row.bold ? 'Helvetica-Bold' : 'Helvetica')
            .fillColor('#333333').text(row.label, 50, y, { width: 250 });
          doc.fontSize(9).font(row.bold ? 'Helvetica-Bold' : 'Helvetica')
            .fillColor(row.color ?? '#000000').text(row.value, 300, y, { width: 245, align: 'right' });
          doc.moveDown(0.2);
        }
        doc.moveDown(0.3);
      }

      if (section.table) {
        const { headers, rows, columnWidths } = section.table;
        const startX = 50;
        const pageWidth = 495;
        const colCount = headers.length;
        const widths = columnWidths ?? headers.map(() => pageWidth / colCount);

        // Header row
        let x = startX;
        const headerY = doc.y;
        doc.fontSize(8).font('Helvetica-Bold').fillColor('#1e3a5f');
        for (let i = 0; i < headers.length; i++) {
          doc.text(headers[i], x, headerY, { width: widths[i], align: i === 0 ? 'left' : 'right' });
          x += widths[i];
        }
        doc.moveDown(0.3);
        doc.strokeColor('#cccccc').lineWidth(0.5).moveTo(50, doc.y).lineTo(545, doc.y).stroke();
        doc.moveDown(0.2);

        // Data rows
        for (const row of rows) {
          x = startX;
          const rowY = doc.y;
          doc.fontSize(8).font(row.bold ? 'Helvetica-Bold' : 'Helvetica').fillColor('#333333');
          for (let i = 0; i < row.cells.length; i++) {
            doc.text(row.cells[i], x, rowY, { width: widths[i], align: i === 0 ? 'left' : 'right' });
            x += widths[i];
          }
          doc.moveDown(0.2);
        }
        doc.moveDown(0.3);
      }
    }

    // Footer
    const bottomY = doc.page.height - 50;
    doc.fontSize(7).font('Helvetica').fillColor('#999999')
      .text(`Generated by Mari8x Maritime Platform â€” ${new Date().toISOString().split('T')[0]}`, 50, bottomY, { align: 'center' });

    doc.end();
  });
}
